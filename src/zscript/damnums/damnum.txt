/*
 * DamNums: by Xaser Acheron
 */

class DamNum : Actor
{
	string fontPrefix;
	int digitCount;
	int digitPlace;
	uint8 digitValue;
	name damageType;
	
	const FADE_AMT = 0.05;
	const DAMAGE_CAP = 99999;
	
	Default
	{
		RenderStyle 'Add';
		Alpha 1.0;
		Gravity 0.4;
		Scale 0.75;

		-SOLID;
		+NOBLOCKMAP;
		+NOBLOCKMONST;
		+THRUACTORS;
		+BRIGHT
		+NOINTERACTION
		+NOTONAUTOMAP
	}
	States
	{
	Spawn:
		"####" "##########" 1 Bright A_DamNumMovement();
		"####" "#" 1 Bright A_DamNumMovement(FADE_AMT);
		Wait;
	}

	/*
	 * DamNum movement function. Handles gravity and/or floatiness.
	 * [Coulda done this in a tick function, but nah.
	 */
	void A_DamNumMovement(double fade = 0)
	{
		// [TODO] switch movement types here
		vel.z -= Gravity;

		// fade to nothing
		if (fade) 
		{
			A_FadeOut(fade, 1);
		}
	}

	/*
	 * DamNum setup function. Sets the correct sprite based
	 * on the digit and the place/number-length. This is necessary
	 * to offset it correctly relative to the viewer.
	 */
	override void PostBeginPlay()
	{
		// Figure out what digit we are.
		DamNum this = DamNum(self);
		int digitCount = (this.digitCount == 0) ? 1 : this.digitCount;
		int digitPlace = (this.digitPlace == 0) ? 1 : this.digitPlace;
		string fontPrefix = (this.fontPrefix == "") ? "ND" : this.fontPrefix;

		// set the sprite based on the above info.
		sprite = GetSpriteIndex(fontPrefix .. digitCount .. digitPlace);
		
		// set the frame to the desired digit; since frames A-J (which is 0-9
		// in integer-speak) correspond exactly to the digits 0-9, we're good. Whoop!
		frame = digitValue;
	}

	/*
	 * Spawn damage numbers. Does what it says on the tin.
	 */
	static int spawnDamageNumbers(Vector3 position = (0,0,0), int damage = 0, Name damagetype = 'Default') 
	{
		// [TODO] move this to the constants file when it's possible.
		static const String DamNum_Translations[] =
		{	 "DamBrick"
		,	 "DamTan"
		,	 "DamGray"
		,	 "DamGreen"
		,	 "DamBrown"
		,	 "DamGold"
		,	 "DamRed"
		,	 "DamBlue"
		,	 "DamOrange"
		,	 "DamWhite"
		,	 "DamYellow"
		,	 "DamDefault"
		,	 "DamBlack"
		,	 "DamLightBlue"
		,	 "DamCream"
		,	 "DamOlive"
		,	 "DamDarkGreen"
		,	 "DamDarkRed"
		,	 "DamDarkBrown"
		,	 "DamPurple"
		,	 "DamDarkGray"
		,	 "DamCyan"
		};

		// angle toward the console player just a bit. This is safe now
		// that the nums have +NOINTERACTION.
		Actor curPlayer = players[consoleplayer].mo;
		Vector3 posDiff = (curPlayer.pos - position);
		double ang = ((atan2(posDiff.y, posDiff.x) + 360.0) % 360.0) + frandom(-20, 20);

		// pre-calculate velocity so we can apply it to all spawned nums.
		vector3 nvel = (1.0 * cos(ang), 1.0 * sin(ang), frandom(3.0, 4.0));

		// figure out which font to use. This is done here so it doesn't have to
		// be determined for every single digit.

		// [XA] I may turn this into something more interesting than an ugly ol'
		//      switch statement, but laziness prevails at present. Plus I dunno
		//      if we can initialize a const array of structs (yet?)

		// [XA] If I can instantiate a class by name (i.e. what's in dam_font),
		//      that would let me just make a base class and do it that way.
		//      Perhaps make them Actors and replace the FontCache concept.
	
		string fontPrefix;
		string fontTrans;
		double fontScale;
		double fontAlpha;
		int    fontRender;
	
		CVar cv = CVar.FindCvar("dam_font");
		int cval = (cv) ? cv.GetInt() : 0;

		switch(cval)
		{

			case DAM_FONT_SMALL:
				fontPrefix = "NS";
				fontTrans  = "DamRed";
				fontScale  = 1.0;
				fontAlpha  = 0.75;
				fontRender = STYLE_Translucent;
				break;

			case DAM_FONT_MODERN:
				fontPrefix = "ND";
				fontTrans  = "DamWhite";
				fontScale  = 1.0;
				fontAlpha  = 1.0;
				fontRender = STYLE_Add;
				break;

			default: // DAM_FONT_CLASSIC
				fontPrefix = "NC";
				fontTrans  = "DamRed";
				fontScale  = 0.75;
				fontAlpha  = 0.75;
				fontRender = STYLE_Translucent;
		}

		// check to see if the user is opting for a particular
		// color choice. If so, use it.
		cv = CVar.FindCvar("dam_color");
		int userColor = cv ? cv.GetInt() : 0;
		if(userColor >= 0 && userColor < DamNum_Translations.Size()) 
		{
			fontTrans = DamNum_Translations[userColor];
		}

		// spawn in the damage number digits.
		int dam = min(damage, DAMAGE_CAP);
		int place = 1;
		int length = log10(dam) + 1;
		while(dam > 0) {
			let damnum = DamNum(Spawn("DamNum", position, ALLOW_REPLACE));

			// init the digits... diginit?
			if(damnum) {
				damnum.vel = nvel;
				damnum.angle = ang;
				damnum.A_SetScale(fontScale, fontScale);
				damnum.A_SetRenderStyle(fontAlpha, fontRender);
				damnum.A_SetTranslation(fontTrans);
				damnum.fontPrefix = fontPrefix;
				damnum.digitCount = length;
				damnum.digitPlace = place;
				damnum.digitValue = dam % 10;
				damnum.damageType = damagetype;
			}

			// well dam.
			dam /= 10;
			place++;
		}

		// return the damage, for easy chaining.
		return damage;
	}
}
